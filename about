<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glitch Horror Transition</title>
    <style>
        :root {
            --crimson: #990000;
            --slime-green: #32CD32;
            --dark-purple: #4B0082;
            --bg-black: #050505;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-black);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Courier New', Courier, monospace;
        }

        /* Container to maintain 16:9 resolution aspect ratio */
        #stage {
            position: relative;
            width: 100vw;
            height: 56.25vw; /* 16:9 ratio */
            max-height: 100vh;
            max-width: 177.78vh; /* 16:9 ratio */
            background: #000;
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0,0,0,1);
        }

        /* Header Styling */
        .stream-status {
            position: absolute;
            top: 5%;
            width: 100%;
            text-align: center;
            color: #444; /* Dim color until glitch */
            font-size: 3.5vw;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 1.5vw;
            z-index: 5;
            animation: subtle-flicker 4s infinite;
        }

        @keyframes subtle-flicker {
            0%, 100% { opacity: 0.8; color: #444; }
            50% { opacity: 0.6; color: #333; }
            51% { opacity: 1; color: #666; text-shadow: 2px 0 var(--crimson); }
            52% { opacity: 0.8; color: #444; text-shadow: none; }
        }

        /* CRT Scanline Overlay */
        #stage::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 10;
            background-size: 100% 4px, 3px 100%;
            pointer-events: none;
        }

        /* Flickering Screen effect */
        @keyframes flicker {
            0% { opacity: 0.97; }
            5% { opacity: 0.95; }
            10% { opacity: 0.9; }
            15% { opacity: 0.98; }
            30% { opacity: 0.95; }
            50% { opacity: 0.9; }
            80% { opacity: 0.99; }
            100% { opacity: 0.95; }
        }

        .glitch-text {
            position: absolute;
            font-weight: bold;
            font-size: 5vw;
            text-transform: uppercase;
            letter-spacing: 0.5vw;
            user-select: none;
            text-shadow: 2px 0 #fff, -2px 0 #fff;
            opacity: 0;
            pointer-events: none;
            z-index: 4;
        }

        /* Glitch movement and chromatic aberration */
        @keyframes glitch-anim {
            0% { transform: translate(0); opacity: 1; clip-path: inset(10% 0 10% 0); }
            10% { transform: translate(-5px, 2px); clip-path: inset(5% 0 80% 0); }
            20% { transform: translate(5px, -2px); clip-path: inset(80% 0 5% 0); }
            30% { transform: translate(-2px, 5px); clip-path: inset(10% 0 10% 0); }
            40% { transform: translate(2px, -5px); clip-path: inset(40% 0 40% 0); }
            50% { transform: translate(-10px, 0); clip-path: inset(0 0 90% 0); opacity: 1; }
            60% { transform: translate(10px, 0); clip-path: inset(90% 0 0 0); }
            100% { transform: translate(0); opacity: 0; }
        }

        .crimson { color: var(--crimson); text-shadow: 3px 0 rgba(255,0,0,0.7), -3px 0 rgba(0,255,255,0.7); }
        .green { color: var(--slime-green); text-shadow: 3px 0 rgba(0,255,0,0.7), -3px 0 rgba(255,0,255,0.7); }
        .purple { color: var(--dark-purple); text-shadow: 3px 0 rgba(150,0,255,0.7), -3px 0 rgba(0,255,0,0.7); }

        .active {
            animation: glitch-anim 0.2s infinite, flicker 0.1s infinite;
            opacity: 1 !important;
        }

        #static-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.05;
            z-index: 1;
        }
    </style>
</head>
<body>

    <div id="stage">
        <div class="stream-status">Stream Ending</div>
        <canvas id="static-canvas"></canvas>
        <div id="ui-layer"></div>
    </div>

    <script>
        const stage = document.getElementById('stage');
        const uiLayer = document.getElementById('ui-layer');
        const canvas = document.getElementById('static-canvas');
        const ctx = canvas.getContext('2d');

        const phrases = [
            { text: "TRUST US", class: "crimson" },
            { text: "OBEY", class: "green" },
            { text: "FOLLOW ME", class: "purple" }
        ];

        // Resize static canvas with error prevention
        function resize() {
            // Use client dimensions or fallback to window
            const w = stage.clientWidth || window.innerWidth || 1920;
            const h = stage.clientHeight || window.innerHeight || 1080;
            
            canvas.width = w;
            canvas.height = h;
        }
        window.addEventListener('resize', resize);
        resize();

        // Background grain/static effect
        function renderStatic() {
            // Guard against zero width/height before creating image data
            if (canvas.width > 0 && canvas.height > 0) {
                try {
                    const idata = ctx.createImageData(canvas.width, canvas.height);
                    const buffer = new Uint32Array(idata.data.buffer);
                    for (let i = 0; i < buffer.length; i++) {
                        if (Math.random() > 0.98) {
                            buffer[i] = 0xffffffff;
                        }
                    }
                    ctx.putImageData(idata, 0, 0);
                } catch (e) {
                    // Fail silently or retry if dimensions were briefly invalid
                }
            }
            requestAnimationFrame(renderStatic);
        }

        function spawnText() {
            const config = phrases[Math.floor(Math.random() * phrases.length)];
            const el = document.createElement('div');
            el.className = `glitch-text ${config.class} active`;
            el.innerText = config.text;

            // Random positioning within the lower 16:9 box to avoid overlap with header
            const x = Math.random() * 60 + 10; 
            const y = Math.random() * 50 + 25; // Centered vertically, lower than top
            
            el.style.left = `${x}%`;
            el.style.top = `${y}%`;

            uiLayer.appendChild(el);

            // Lifetime of the phrase (fast vanishing)
            const duration = 400 + Math.random() * 600; 
            
            setTimeout(() => {
                el.classList.remove('active');
                el.style.opacity = '0';
                setTimeout(() => el.remove(), 100);
            }, duration);
        }

        // Cycle through spawning
        function burst() {
            const count = 3 + Math.floor(Math.random() * 4);
            for(let i=0; i<count; i++) {
                setTimeout(spawnText, i * 150);
            }
            
            // Wait a few seconds before the next "episode" of flashing
            setTimeout(burst, 2000 + Math.random() * 3000);
        }

        // Start the sequence after ensuring initial dimensions
        window.onload = () => {
            resize();
            renderStatic();
            burst();
        };

        // Click to trigger a manual glitch burst
        stage.addEventListener('click', () => {
            for(let i=0; i<10; i++) spawnText();
        });

    </script>
</body>
</html>
